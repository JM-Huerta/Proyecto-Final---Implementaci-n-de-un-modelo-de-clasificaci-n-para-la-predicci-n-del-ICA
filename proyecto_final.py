# -*- coding: utf-8 -*-
"""Proyecto Final.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18BolAJcXDTzMVGECcKGJQyOjjfAWcxfy

#Proyecto Final

Para el proyecto final, se aplicara una tecnica de clasificación con el propósito de clasificar correctamente el ICA (índice de la Calidad del Aire), mediante los parametros de entrada (los 6 contaminantes más importantes).

## Librerías

Empezamos con la implementación de librerías a ocupar dentro de nuestro modelo de clasificación, además de las metricas para evaluarlo, funciones para visualizar histogramas y que nos ayudaran a dividir nuestros datos en entrenamineto y testeo.
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import classification_report

"""## Lectura y Evaluación de los Datos

Se almacenaran los datos dentro de un DataFrame. Se puede observar que se cuentan con dos archivos ".csv", uno con los registros de los contaminantes de 3 estaciones, mientras que el segundo contiene los datos del sensor, esto se hace con el proposito de conocer que componente es el que se esta obteniendo.
"""

# Leer los dos archivos CSV
contaminantes = pd.read_csv('Contaminantes.csv', usecols=['ID_SENSOR', 'FECHA', 'VALOR_MEDIDA'])
sensores = pd.read_csv('Sensores.csv', usecols=['ID_SENSOR', 'CONTAMINANTE'])

# Realizar la unión medainte la funcion "merge" entre los DataFrames basándote en "ID_SENSOR" como variable de referencia en ambos DataFrames
datos = pd.merge(contaminantes, sensores, on='ID_SENSOR')

# Crear un nuevo DataFrame que contendra las columnas que deseamos considerar para el modelo
dfUnion = ['ID_SENSOR', 'FECHA', 'VALOR_MEDIDA', 'CONTAMINANTE']
dfUnion = datos[dfUnion]

"""### Procesamiento de los Datos

Se realizara una validación de los datos, y después se validara si es necesario el aplicar algun procesamiento sobre estos para emplementarlos en el modelo.
"""

dfUnion

dfUnion.info()

nulos = dfUnion.isnull().sum()
columnas_con_nulos = nulos[nulos > 0]

print(columnas_con_nulos)

"""Al visualizar que los datos no contenian nulos, se realizo una extración de cada componente, de tal manera que sea más sencillo trabajar con los datos y en la aplicación del modelo, por lo cual se crearon DataFrames para los 6 principales contaminantes con los que se contempra el ICA, descartando los demás.

Después se uniran en uno solo DataFrame y se anexar un nuevo parametro "ICA", calculandolo referente a los componentes, teniendo como base, que estos seran normalizados y con ello los parametros para establecer el ICA.

### DataFrame CO
"""

DataFrame_CO = dfUnion[dfUnion['CONTAMINANTE'] == 'CO'][['FECHA', 'VALOR_MEDIDA']]

# Renombramos la columna 'VALOR_MEDIDA' a 'CO'
DataFrame_CO = DataFrame_CO.rename(columns={'VALOR_MEDIDA': 'CO'})

# Ordenamos por FECHA
DataFrame_CO = DataFrame_CO.sort_values('FECHA')

DataFrame_CO

"""### DataFrame O3"""

DataFrame_O3 = dfUnion[dfUnion['CONTAMINANTE'] == 'O3'][['FECHA', 'VALOR_MEDIDA']]

# Renombramos la columna 'VALOR_MEDIDA' a 'O3'
DataFrame_O3 = DataFrame_O3.rename(columns={'VALOR_MEDIDA': 'O3'})

# Ordenamos por FECHA
DataFrame_O3 = DataFrame_O3.sort_values('FECHA')

DataFrame_O3

"""### DataFrame SO2"""

# Creamos el nuevo DataFrame_CO
DataFrame_SO2 = dfUnion[dfUnion['CONTAMINANTE'] == 'SO2'][['FECHA', 'VALOR_MEDIDA']]

# Renombramos la columna 'VALOR_MEDIDA' a 'SO2'
DataFrame_SO2 = DataFrame_SO2.rename(columns={'VALOR_MEDIDA': 'SO2'})

# Ordenamos por FECHA
DataFrame_SO2 = DataFrame_SO2.sort_values('FECHA')

DataFrame_SO2

"""### DataFrame NO2"""

DataFrame_NO2 = dfUnion[dfUnion['CONTAMINANTE'] == 'NO2'][['FECHA', 'VALOR_MEDIDA']]

# Renombramos la columna 'VALOR_MEDIDA' a 'NO2'
DataFrame_NO2 = DataFrame_NO2.rename(columns={'VALOR_MEDIDA': 'NO2'})

# Ordenamos por FECHA
DataFrame_NO2 = DataFrame_NO2.sort_values('FECHA')

DataFrame_NO2

"""### DataFrame PM10"""

DataFrame_PM10 = dfUnion[dfUnion['CONTAMINANTE'] == 'PM10'][['FECHA', 'VALOR_MEDIDA']]

# Renombramos la columna 'VALOR_MEDIDA' a 'PM10'
DataFrame_PM10 = DataFrame_PM10.rename(columns={'VALOR_MEDIDA': 'PM10'})

# Ordenamos por FECHA
DataFrame_PM10 = DataFrame_PM10.sort_values('FECHA')

DataFrame_PM10

"""### DataFrame PM2.5"""

DataFrame_PM2_5 = dfUnion[dfUnion['CONTAMINANTE'] == 'PM2.5'][['FECHA', 'VALOR_MEDIDA']]

# Renombramos la columna 'VALOR_MEDIDA' a 'PM10'
DataFrame_PM2_5 = DataFrame_PM2_5.rename(columns={'VALOR_MEDIDA': 'PM2.5'})

# Ordenamos por FECHA
DataFrame_PM2_5 = DataFrame_PM2_5.sort_values('FECHA')

DataFrame_PM2_5

dfcontaminantes = DataFrame_CO.merge(DataFrame_O3, on='FECHA') \
    .merge(DataFrame_SO2, on='FECHA') \
    .merge(DataFrame_NO2, on='FECHA') \
    .merge(DataFrame_PM10, on='FECHA') \
    .merge(DataFrame_PM2_5, on='FECHA')

# Crear un nuevo DataFrame que contendra los 6 contaminantes
df = ['FECHA', 'CO', 'O3', 'SO2', 'NO2', 'PM10', 'PM2.5']
df = dfcontaminantes[df]

df

"""Ahora se realizara una visualización de los outliers que puedan existir en nuestros datos."""

plt.figure(figsize=(12, 6))
sns.boxplot(data=df[['PM2.5', 'PM10', 'O3', 'NO2', 'SO2', 'CO']], orient='h')
plt.title('Visualización de Outliers')
plt.xlabel('Valores de Contaminantes')
plt.ylabel('Contaminantes')
plt.show()

# Función para eliminar outliers aplicando el método IQR
def eliminar_outliers(df, column):
    Q1 = df[column].quantile(0.25)
    Q3 = df[column].quantile(0.75)
    IQR = Q3 - Q1
    lower_bound = Q1 - 1.5 * IQR
    upper_bound = Q3 + 1.5 * IQR
    df = df[(df[column] >= lower_bound) & (df[column] <= upper_bound)]
    return df

for contaminante in ['PM2.5', 'PM10', 'O3', 'NO2', 'SO2', 'CO']:
    df = eliminar_outliers(df, contaminante)

"""A continuación verificaremos como se visualizan ahora, después de haber eliminado los outliers."""

plt.figure(figsize=(12, 6))
sns.boxplot(data=df[['PM2.5', 'PM10', 'O3', 'NO2', 'SO2', 'CO']], orient='h')
plt.title('Visualización después de eliminar los Outliers')
plt.xlabel('Valores de Contaminantes')
plt.ylabel('Contaminantes')
plt.show()

def obtener_calidad_aire(pm25, pm10, o3, no2, so2, co):
    if pm25 <= 25 and pm10 <= 50 and o3 <= 0.051 and no2 <= 0.107 and so2 <= 0.008 and co <= 8.75:
        return 'buena'
    elif pm25 <= 45 and pm10 <= 75 and o3 <= 0.070 and no2 <= 0.120 and so2 <= 0.110 and co <= 11.0:
        return 'aceptable'
    elif pm25 <= 79 and pm10 <= 155 and o3 <= 0.092 and no2 <= 0.230 and so2 <= 0.165 and co <= 13.30:
        return 'mala'
    elif pm25 <= 147 and pm10 <= 235 and o3 <= 0.114 and no2 <= 0.250 and so2 <= 0.220 and co <= 15.50:
        return 'muy mala'
    else:
        return 'extremadamente mala'

# Normalización de los datos
contaminantes = ['PM2.5', 'PM10', 'O3', 'NO2', 'SO2', 'CO']
scaler = StandardScaler()
df[contaminantes] = scaler.fit_transform(df[contaminantes])

# Determinar la calidad del aire para cada registro
df['calidad_aire'] = df.apply(lambda row: obtener_calidad_aire(row['PM2.5'], row['PM10'], row['O3'], row['NO2'], row['SO2'], row['CO']), axis=1)

df

df.info()

df.describe()

"""## Modelo"""

# Definir las características (X) y la etiqueta (y)
contaminantes = ['PM2.5', 'PM10', 'O3', 'NO2', 'SO2', 'CO']

X = df[contaminantes]
y = df['calidad_aire']

# División los datos
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.5, random_state=42)

clf = RandomForestClassifier(random_state=50)
clf.fit(X_train, y_train)

"""## Evaluación"""

y_pred = clf.predict(X_test)
report = classification_report(y_test, y_pred, target_names=['buena', 'aceptable', 'mala', 'muy mala', 'extremadamente mala'])
print(report)

"""# Juan Manuel Huerta Ordaz"""